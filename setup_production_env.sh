#!/bin/bash
# NeuroInsight Production Environment Setup Script
# Automatically configures environment variables for production deployment
# Supports both native and hybrid deployment modes

set -e

echo "ðŸ”§ NeuroInsight Production Environment Setup"
echo "==========================================="

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Configuration files
ENV_NATIVE="${PROJECT_DIR}/.env.native"
ENV_PRODUCTION="${PROJECT_DIR}/.env.production"
ENV_FILE="${PROJECT_DIR}/.env"
ENV_BACKUP="${PROJECT_DIR}/.env.backup.$(date +%Y%m%d_%H%M%S)"

# Deployment types
DEPLOYMENT_TYPE=""
FORCE=false
QUIET=false

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    [ "$QUIET" = false ] && echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
    [ "$QUIET" = false ] && echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
    [ "$QUIET" = false ] && echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}" >&2
}

# Function to generate secure random password
generate_password() {
    local length=${1:-32}
    # Use openssl for cryptographically secure random generation
    openssl rand -base64 48 | tr -d "=+/" | cut -c1-"$length"
}

# Function to generate secure random string
generate_secret() {
    local length=${1:-64}
    openssl rand -hex "$length"
}

# Function to detect available deployment options
detect_deployment_options() {
    log_info "Detecting available deployment options..."

    local has_docker=false
    local has_podman=false
    local has_sudo=false

    # Check for container runtimes
    if command -v docker &> /dev/null && docker info &> /dev/null; then
        has_docker=true
        log_success "Docker detected and available"
    fi

    if command -v podman &> /dev/null; then
        has_podman=true
        log_success "Podman detected"
    fi

    # Check for sudo access
    if sudo -n true 2>/dev/null; then
        has_sudo=true
        log_success "Sudo access available"
    fi

    # Determine best deployment type
    if [ "$has_docker" = true ] || [ "$has_podman" = true ]; then
        DEPLOYMENT_TYPE="hybrid"
        log_info "Recommended: Hybrid deployment (containers for databases)"
    elif [ "$has_sudo" = true ]; then
        DEPLOYMENT_TYPE="native"
        log_info "Recommended: Native deployment (system services)"
    else
        DEPLOYMENT_TYPE="hybrid"
        log_warning "Limited options: Hybrid deployment (may require manual container setup)"
    fi

    echo "$DEPLOYMENT_TYPE"
}

# Function to backup existing configuration
backup_existing_config() {
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "$ENV_BACKUP"
        log_info "Backed up existing .env to: $(basename "$ENV_BACKUP")"
    fi
}

# Function to setup native deployment configuration
setup_native_config() {
    log_info "Setting up Fully Native deployment configuration..."

    # Generate secure passwords
    local postgres_password=$(generate_password 32)
    local minio_secret=$(generate_password 32)
    local secret_key=$(generate_secret 64)

    # Create .env.native
    cat > "$ENV_NATIVE" << EOF
# NeuroInsight Fully Native Production Configuration
# Generated by setup_production_env.sh on $(date)

# Application Configuration
APP_NAME=NeuroInsight
APP_VERSION=1.0.0
ENVIRONMENT=production
LOG_LEVEL=INFO

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000
CORS_ORIGINS=http://localhost:8000,http://localhost:80

# PostgreSQL Database Configuration (Native)
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=neuroinsight
POSTGRES_PASSWORD=${postgres_password}
POSTGRES_DB=neuroinsight

# Redis Configuration (Native)
REDIS_HOST=localhost
REDIS_PORT=6379

# Celery Configuration
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0
CELERY_TIMEZONE=UTC

# MinIO Object Storage Configuration (Native)
MINIO_ACCESS_KEY=neuroinsight_minio
MINIO_SECRET_KEY=${minio_secret}
MINIO_ENDPOINT=localhost:9000
MINIO_BUCKET=neuroinsight
MINIO_USE_SSL=false

# File Storage Paths
UPLOAD_DIR=./data/uploads
OUTPUT_DIR=./data/outputs
LOG_DIR=./data/logs

# Security
SECRET_KEY=${secret_key}

# Processing Configuration
MAX_CONCURRENT_JOBS=2
PROCESSING_TIMEOUT=18000

# FreeSurfer Configuration
# Container runtime selection will auto-detect available options
# Priority: Docker â†’ Apptainer/Singularity â†’ Native FreeSurfer â†’ Mock

# Service Data Directories (for native deployment)
POSTGRES_DATA_DIR=./data/postgresql
REDIS_DATA_DIR=./data/redis
MINIO_DATA_DIR=./data/minio

# PID Files (for process management)
BACKEND_PID=./backend.pid
CELERY_PID=./celery.pid
REDIS_PID=./redis.pid
MINIO_PID=./minio.pid

# Deployment Information
DEPLOYMENT_TYPE=native
GENERATED_AT=$(date)
GENERATED_BY=setup_production_env.sh
EOF

    log_success "Created .env.native with secure passwords"

    # Display generated passwords securely
    if [ "$QUIET" = false ]; then
        echo ""
        echo "ðŸ” Generated Secure Credentials:"
        echo "================================="
        echo "PostgreSQL Password: ${postgres_password}"
        echo "MinIO Secret Key:    ${minio_secret}"
        echo "Application Secret:  ${secret_key}"
        echo ""
        log_warning "Save these passwords securely! They are required for database access."
        echo ""
    fi
}

# Function to setup hybrid deployment configuration
setup_hybrid_config() {
    log_info "Setting up Production Hybrid deployment configuration..."

    # Generate secure passwords
    local postgres_password=$(generate_password 32)
    local redis_password=$(generate_password 32)
    local minio_secret=$(generate_password 32)
    local secret_key=$(generate_secret 64)

    # Create .env.production
    cat > "$ENV_PRODUCTION" << EOF
# NeuroInsight Production Hybrid Configuration
# Generated by setup_production_env.sh on $(date)
# Uses containers for PostgreSQL, Redis, MinIO

# Application Configuration
APP_NAME=NeuroInsight
APP_VERSION=1.0.0
ENVIRONMENT=production
LOG_LEVEL=INFO

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000
CORS_ORIGINS=http://localhost:8000,http://localhost:80

# PostgreSQL Database Configuration (Container)
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=neuroinsight
POSTGRES_PASSWORD=${postgres_password}
POSTGRES_DB=neuroinsight

# Redis Configuration (Container)
REDIS_HOST=localhost
REDIS_PORT=6379

# Celery Configuration
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0
CELERY_TIMEZONE=UTC

# MinIO Object Storage Configuration (Container)
MINIO_ACCESS_KEY=neuroinsight_minio
MINIO_SECRET_KEY=${minio_secret}
MINIO_ENDPOINT=localhost:9000
MINIO_BUCKET=neuroinsight
MINIO_USE_SSL=false

# File Storage Paths
UPLOAD_DIR=./data/uploads
OUTPUT_DIR=./data/outputs
LOG_DIR=./data/logs

# Security
SECRET_KEY=${secret_key}

# Processing Configuration
MAX_CONCURRENT_JOBS=2
PROCESSING_TIMEOUT=18000

# FreeSurfer Configuration
# Container runtime selection will auto-detect available options
# Priority: Docker â†’ Apptainer/Singularity â†’ Native FreeSurfer â†’ Mock

# Deployment Information
DEPLOYMENT_TYPE=hybrid
GENERATED_AT=$(date)
GENERATED_BY=setup_production_env.sh
EOF

    log_success "Created .env.production with secure passwords"

    # Display generated passwords securely
    if [ "$QUIET" = false ]; then
        echo ""
        echo "ðŸ” Generated Secure Credentials:"
        echo "================================="
        echo "PostgreSQL Password: ${postgres_password}"
        echo "MinIO Secret Key:    ${minio_secret}"
        echo "Application Secret:  ${secret_key}"
        echo ""
        log_warning "Save these passwords securely! They are required for database access."
        echo ""
    fi
}

# Function to validate configuration
validate_config() {
    local config_file="$1"
    local config_name="$2"

    log_info "Validating $config_name configuration..."

    # Check if file exists
    if [ ! -f "$config_file" ]; then
        log_error "$config_name configuration file not found"
        return 1
    fi

    # Basic validation - check for required variables
    local required_vars=("SECRET_KEY" "POSTGRES_PASSWORD" "MINIO_SECRET_KEY")
    local missing_vars=()

    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$config_file"; then
            missing_vars+=("$var")
        fi
    done

    if [ ${#missing_vars[@]} -gt 0 ]; then
        log_error "Missing required variables in $config_name: ${missing_vars[*]}"
        return 1
    fi

    log_success "$config_name configuration is valid"
    return 0
}

# Function to migrate from existing configuration
migrate_existing_config() {
    if [ -f "$ENV_FILE" ] && [ "$FORCE" = false ]; then
        log_warning "Existing .env file found"
        echo "Choose migration option:"
        echo "1. Keep existing configuration"
        echo "2. Update with new secure passwords"
        echo "3. Backup and replace completely"

        if [ "$QUIET" = false ]; then
            read -p "Enter choice (1-3): " choice
        else
            choice="2"  # Default to update in quiet mode
        fi

        case $choice in
            1)
                log_info "Keeping existing configuration"
                return 0
                ;;
            2)
                log_info "Updating existing configuration with new passwords..."
                # Extract existing values and update passwords
                # This is a simplified version - in production you'd want more sophisticated migration
                ;;
            3)
                backup_existing_config
                log_info "Replacing with new configuration"
                ;;
            *)
                log_error "Invalid choice"
                return 1
                ;;
        esac
    fi
}

# Function to display usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Automatically setup NeuroInsight production environment configuration"
    echo ""
    echo "OPTIONS:"
    echo "  -t, --type TYPE     Deployment type: native, hybrid, or auto (default: auto)"
    echo "  -f, --force         Force overwrite existing configuration"
    echo "  -q, --quiet         Quiet mode, minimal output"
    echo "  -h, --help          Show this help message"
    echo ""
    echo "EXAMPLES:"
    echo "  $0                    # Auto-detect and setup"
    echo "  $0 --type native      # Setup native deployment"
    echo "  $0 --type hybrid      # Setup hybrid deployment"
    echo "  $0 --force --quiet    # Force setup quietly"
    echo ""
    echo "This script will:"
    echo "  â€¢ Generate secure random passwords"
    echo "  â€¢ Create appropriate .env files"
    echo "  â€¢ Validate configuration"
    echo "  â€¢ Provide deployment instructions"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--type)
            DEPLOYMENT_TYPE="$2"
            shift 2
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    echo "Starting NeuroInsight production environment setup..."
    echo ""

    # Auto-detect deployment type if not specified
    if [ -z "$DEPLOYMENT_TYPE" ] || [ "$DEPLOYMENT_TYPE" = "auto" ]; then
        DEPLOYMENT_TYPE=$(detect_deployment_options)
    fi

    # Validate deployment type
    case $DEPLOYMENT_TYPE in
        native)
            log_info "Selected: Fully Native Deployment"
            ;;
        hybrid)
            log_info "Selected: Production Hybrid Deployment"
            ;;
        *)
            log_error "Invalid deployment type: $DEPLOYMENT_TYPE"
            echo "Valid options: native, hybrid, auto"
            exit 1
            ;;
    esac

    # Handle existing configuration
    migrate_existing_config

    # Setup configuration based on type
    case $DEPLOYMENT_TYPE in
        native)
            setup_native_config
            validate_config "$ENV_NATIVE" "native"
            cp "$ENV_NATIVE" "$ENV_FILE"
            ;;
        hybrid)
            setup_hybrid_config
            validate_config "$ENV_PRODUCTION" "production"
            cp "$ENV_PRODUCTION" "$ENV_FILE"
            ;;
    esac

    # Final success message
    echo ""
    log_success "NeuroInsight production environment configured successfully!"
    echo ""
    echo "ðŸ“ Configuration files created:"
    echo "  â€¢ .env (active configuration)"
    if [ "$DEPLOYMENT_TYPE" = "native" ]; then
        echo "  â€¢ .env.native (native deployment template)"
    else
        echo "  â€¢ .env.production (hybrid deployment template)"
    fi
    echo ""
    echo "ðŸš€ Next steps:"
    if [ "$DEPLOYMENT_TYPE" = "native" ]; then
        echo "  1. sudo ./setup_native_services.sh    # Install system services"
        echo "  2. ./start_production_native.sh       # Start deployment"
    else
        echo "  1. ./start_production_hybrid.sh       # Start deployment"
    fi
    echo "  2. curl http://localhost:8000         # Test application"
    echo ""

    log_info "Setup complete! Your NeuroInsight production environment is ready."
}

# Check for required dependencies
check_dependencies() {
    if ! command -v openssl &> /dev/null; then
        log_error "OpenSSL is required for password generation"
        exit 1
    fi
}

# Run dependency check and main function
check_dependencies
main "$@"








